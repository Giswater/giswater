int pnpoly(int nvert, float *vertx, float *verty, float testx, float testy)
{
  int i, j, c = 0;
  for (i = 0, j = nvert-1; i < nvert; j = i++) {
    if ( ((verty[i]>testy) != (verty[j]>testy)) &&
	 (testx < (vertx[j]-vertx[i]) * (testy-verty[i]) / (verty[j]-verty[i]) + vertx[i]) )
       c = !c;
  }
  return c;
}


Argument Meaning  
nvert  Number of vertices in the polygon. Whether to repeat the first vertex at the end is discussed below.  
vertx, verty  Arrays containing the x- and y-coordinates of the polygon's vertices.  
testx, testy X- and y-coordinate of the test point.  






Sum over the edges, (x2-x1)(y2+y1). If the result is positive the curve is clockwise, if it's negative the curve is counter-clockwise. (The result is twice the enclosed area, with a +/- convention.)

point[0] = (5,0)   edge[0]: (6-5)(4+0) =   4
point[1] = (6,4)   edge[1]: (4-6)(5+4) = -18
point[2] = (4,5)   edge[2]: (1-4)(5+5) = -30
point[3] = (1,5)   edge[3]: (1-1)(0+5) =   0
point[4] = (1,0)   edge[4]: (5-1)(0+0) =   0
                                         ---
                                         -44  counter-clockwise








Let's assume that we have a Vector type having X and Y properties of type double.

public bool IsClockwise(IList<Vector> vertices)
{
    double sum = 0.0;
    for (int i = 0; i < vertices.Count; i++) {
        Vector v1 = vertices[i];
        Vector v2 = vertices[(i + 1) % vertices.Count];
        sum += (v2.X - v1.X) * (v2.Y + v1.Y);
    }
    return sum > 0.0;
}


float points[9] = { 3, 4, 2, 8, 1, 4, -4, 4, 3 }; // float array with 3 data points in the form of x,y,z

float plane[4]; // will contain the computed plane equation result

fm_computeBestFitPlane(3, // we have 3 data points.
points, // the address of the X component of the first data point.
sizeof(float)*3, // The stride (distance in bytes) between one point and the next.
NULL, // pass a null pointer for weights
0, // pass a zero for weight stride.
plane); // the address of the plane equation to store the result.












        uas11     = ua(1,nubo1)
        uas21     = ua(2,nubo1)
        uas31     = ua(3,nubo1)
!
        uas12     = ua(1,nubo2)
        uas22     = ua(2,nubo2)
        uas32     = ua(3,nubo2)

!
!		Determinamos el lado upwind (el vector va de nubo2 a nubo1)
		vecx = vnocl(1,nsg)
		vecy = vnocl(2,nsg)
!
!		Determinamos las componentes normales y tangenciales.
!		Pasamos de coordenadas generales a locales:
!
!		Xn = (vecx,vecy)
!		Xt = (-vecx,vecy)
!
!		[M]_LG = [Xn Xt]   = [vecx -vecy]
!							 [vecy  vecx]
!
!		[M]_GL = [Xn Xt]^t = [vecx  vecy]
!							 [-vecy vecx]
!
!
       	hR  = uas11
		huR =   vecx * uas21 + vecy * uas31
   		hvR = - vecy * uas21 + vecx * uas31
		uR  =   vecx * uas41 + vecy * uas51
   		vR  = - vecy * uas41 + vecx * uas51
!
    	hL  = uas12
		huL =   vecx * uas22 + vecy * uas32
   		hvL = - vecy * uas22 + vecx * uas32
		uL  =   vecx * uas42 + vecy * uas52
   		vL  = - vecy * uas42 + vecx * uas52




CONTROL SECADO MOJADO

!		Dry/Wetting front control
		EnergyCheck(1) = 1.d0
		EnergyCheck(2) = 1.d0




INICIALIZAR LOS FLUJOS

    do is=1,ns
!
!		Todas las variables
		do ivar=1,nvar
			ce(ivar,is) = 0.0d0
		enddo
!
	enddo

ACTUALIZAR FLUJOS

!
!   Vector normal a la cara (va de nubo2 a nubo1)
    xnn       = vnocl(1,nsg)
    ynn       = vnocl(2,nsg)
    rnn       = vnocl(3,nsg)
!
!   gathering of the elementary fluxes into the global ones 
!
!	Flujo usado para la parte convectiva del modelo k-e
    fluro(nsg) = fstar(1)
!
!	Los flujos son L (-) para nubo2 y R (+) para nubo1 (vector va de nubo2 a nubo1)
    ce(1,nubo1)    = ce(1,nubo1) + EnergyCheck(1) * rnn * fstar(1)
    ce(2,nubo1)    = ce(2,nubo1) + EnergyCheck(1) * rnn * (fstar(2) * xnn - fstar(3) * ynn)
    ce(3,nubo1)    = ce(3,nubo1) + EnergyCheck(1) * rnn * (fstar(2) * ynn + fstar(3) * xnn)
!
    ce(1,nubo2)    = ce(1,nubo2) - EnergyCheck(2) * rnn * fstar(1)
    ce(2,nubo2)    = ce(2,nubo2) - EnergyCheck(2) * rnn * (fstar(2) * xnn - fstar(3) * ynn)
    ce(3,nubo2)    = ce(3,nubo2) - EnergyCheck(2) * rnn * (fstar(2) * ynn + fstar(3) * xnn)
!



ACTUALIZAR VALORES VOLUMEN DE CONTROL

!
    do is =1,ns
!
!		Delta de t local, dividido por el area del volumen de control
		usais            = dtl(is)/airs(is)
!
		do ivar=1,nvar
			ua(ivar,is)  = un(ivar,is) + alpha(ialpha)*usais*ce(ivar,is)
		enddo
!
!		Control de calados negativos
		if (ua(1,is) .LT. 0.d0) then
		    ua(1:5,is) = 0.d0
	    endif
!
	enddo


